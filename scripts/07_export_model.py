# scripts/07_export_model.py
# Refactored to use centralized utilities and configuration.

import sys
from pathlib import Path
import logging  # Import logging, but setup will be done via utils
import subprocess
import shutil
from typing import Dict, Any, Optional

# --- Import from project utils ---
# Ensure the 'src' directory is in the Python path (handled by runner or Docker)
import src.utils as utils  # Centralized utilities for config, logging

# --- Configuration and Logger Setup (Step 1 & 2) ---
try:
    # Load configuration using the centralized utility (Step 1)
    config = utils.load_config()

    # Setup logging using the centralized utility (Step 2)
    logger = utils.setup_logger(__name__, config)

except Exception as e:
    # If utils.setup_logger fails before creating a logger, fall back to basic config for this critical error
    logging.basicConfig(level=logging.CRITICAL, format='%(asctime)s - %(levelname)s - %(message)s')
    logging.critical(f"Fatal error initializing configuration or logger: {e}")
    sys.exit(1)

# --- Helper Functions ---
# The local load_config function is removed as it's now handled centrally.

def find_latest_checkpoint(checkpoint_dir: Path) -> Optional[Path]:
    """Finds the most recently modified .ckpt file in the checkpoint directory."""
    checkpoints = list(checkpoint_dir.glob("*.ckpt"))
    if not checkpoints:
        # Use the centralized logger
        logger.warning(f"‚ö†Ô∏è No checkpoints found in {checkpoint_dir}")
        return None
    latest_checkpoint = max(checkpoints, key=lambda p: p.stat().st_mtime)
    # Use the centralized logger
    logger.info(f"‚úÖ Found latest checkpoint: {latest_checkpoint.name}")
    return latest_checkpoint

def find_training_config(dataset_dir: Path) -> Optional[Path]:
    """Finds the config.json generated by the Piper trainer."""
    # Piper saves its config in the cache directory within the dataset folder.
    config_path = dataset_dir / "cache" / "config.json"
    if config_path.exists():
        # Use the centralized logger
        logger.info(f"‚úÖ Found training config at: {config_path}")
        return config_path
    # Use the centralized logger
    logger.warning(f"‚ö†Ô∏è Could not find training config.json in {dataset_dir / 'cache'}")
    return None

def main():
    """Main function to export the trained Piper model to ONNX format."""
    # Use the centralized logger
    logger.info("üöÄ Starting Stage 8: Exporting Model to ONNX...")

    try:
        # Configuration is now loaded centrally
        # config = load_config() # Removed
        piper_config = config.get('piper_training', {})

        # --- Centralized Path Management (Step 3) ---
        # Derive all paths from the central config dictionary
        data_base_dir = Path(config.get('data_base_dir', 'data'))
        models_dir = Path(config.get('models_dir', 'models')) # Get models base dir

        # Use potentially configurable subdirectory names from config.yaml
        # Make sure these keys are in your config.yaml:
        # training_checkpoint_dir: "models/checkpoints" (likely already exists)
        # onnx_export_dir: "models/exported_onnx" (likely already exists)
        # piper_dataset_subdir: "05_piper_dataset" (likely already added previously)

        # Use the paths directly from config for checkpoints and ONNX export
        checkpoint_dir = Path(config.get('training_checkpoint_dir', 'models/checkpoints'))
        onnx_export_dir = Path(config.get('onnx_export_dir', 'models/exported_onnx'))

        # Derive dataset directory using the configurable subdirectory
        piper_dataset_subdir = config.get('piper_dataset_subdir', '05_piper_dataset')
        dataset_dir = data_base_dir / piper_dataset_subdir

        onnx_export_dir.mkdir(parents=True, exist_ok=True)

        # --- 1. Find the best checkpoint to export ---
        latest_ckpt = find_latest_checkpoint(checkpoint_dir)
        if not latest_ckpt:
            # Use the centralized logger
            logger.error("‚ùå No trained checkpoint found to export. Please run stage 7 first.")
            sys.exit(1)

        # --- 2. Define output paths ---
        voice_name = piper_config.get('voice_name', 'apoka-v1')
        onnx_path = onnx_export_dir / f"{voice_name}.onnx"
        config_path = onnx_export_dir / f"{voice_name}.onnx.json"

        # --- 3. Construct and run the export command ---
        command = [
            sys.executable, "-m", "piper.train.export_onnx",
            "--checkpoint", str(latest_ckpt),
            "--output-file", str(onnx_path)
        ]

        # Use the centralized logger
        logger.info("üî• Exporting model... This may take a moment.")
        # Use the centralized logger
        logger.info(" ".join(command)) # Log the command being run

        result = subprocess.run(command, check=True, capture_output=True, text=True)

        if result.returncode == 0:
            # Use the centralized logger
            logger.info("‚úÖ Model exported successfully to ONNX format.")
            # Use the centralized logger
            logger.info(f"   -> {onnx_path}")
        else:
            # Use the centralized logger
            logger.error(f"‚ùå Model export failed with exit code {result.returncode}.")
            # Use the centralized logger
            logger.error(result.stderr)
            sys.exit(1)

        # --- 4. Copy the necessary config.json file ---
        training_config_path = find_training_config(dataset_dir)
        if training_config_path:
            shutil.copy(training_config_path, config_path)
            # Use the centralized logger
            logger.info(f"‚úÖ Copied training config to {config_path}")
        else:
            # Use the centralized logger
            logger.warning("‚ö†Ô∏è Could not find the training config.json. The exported model may not work without it.")

        # Use the centralized logger
        logger.info("\nüéâ Model export complete! Your voice is ready for inference.")

    except subprocess.CalledProcessError as e:
        # Use the centralized logger
        logger.error(f"‚ùå A subprocess error occurred during export: {e}")
        # Use the centralized logger
        logger.error(f"Stderr: {e.stderr}")
        sys.exit(1)
    except Exception as e:
        # Use the centralized logger
        logger.error(f"‚ùå A critical error occurred: {e}", exc_info=True)
        sys.exit(1)

if __name__ == "__main__":
    main()